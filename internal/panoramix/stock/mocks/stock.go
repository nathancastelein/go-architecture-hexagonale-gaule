// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/nathancastelein/go-architecture-hexagonale-gaule/internal/panoramix/stock (interfaces: Stock)
//
// Generated by this command:
//
//	mockgen -typed -destination=mocks/stock.go -package stockmocks . Stock
//

// Package stockmocks is a generated GoMock package.
package stockmocks

import (
	reflect "reflect"

	recette "github.com/nathancastelein/go-architecture-hexagonale-gaule/internal/panoramix/recette"
	gomock "go.uber.org/mock/gomock"
)

// MockStock is a mock of Stock interface.
type MockStock struct {
	ctrl     *gomock.Controller
	recorder *MockStockMockRecorder
	isgomock struct{}
}

// MockStockMockRecorder is the mock recorder for MockStock.
type MockStockMockRecorder struct {
	mock *MockStock
}

// NewMockStock creates a new mock instance.
func NewMockStock(ctrl *gomock.Controller) *MockStock {
	mock := &MockStock{ctrl: ctrl}
	mock.recorder = &MockStockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStock) EXPECT() *MockStockMockRecorder {
	return m.recorder
}

// RécupèrerIngrédient mocks base method.
func (m *MockStock) RécupèrerIngrédient(ingrédient recette.Ingrédient) (recette.Ingrédient, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RécupèrerIngrédient", ingrédient)
	ret0, _ := ret[0].(recette.Ingrédient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RécupèrerIngrédient indicates an expected call of RécupèrerIngrédient.
func (mr *MockStockMockRecorder) RécupèrerIngrédient(ingrédient any) *MockStockRécupèrerIngrédientCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RécupèrerIngrédient", reflect.TypeOf((*MockStock)(nil).RécupèrerIngrédient), ingrédient)
	return &MockStockRécupèrerIngrédientCall{Call: call}
}

// MockStockRécupèrerIngrédientCall wrap *gomock.Call
type MockStockRécupèrerIngrédientCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStockRécupèrerIngrédientCall) Return(arg0 recette.Ingrédient, arg1 error) *MockStockRécupèrerIngrédientCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStockRécupèrerIngrédientCall) Do(f func(recette.Ingrédient) (recette.Ingrédient, error)) *MockStockRécupèrerIngrédientCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStockRécupèrerIngrédientCall) DoAndReturn(f func(recette.Ingrédient) (recette.Ingrédient, error)) *MockStockRécupèrerIngrédientCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StockerIngrédient mocks base method.
func (m *MockStock) StockerIngrédient(ingrédient recette.Ingrédient) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StockerIngrédient", ingrédient)
}

// StockerIngrédient indicates an expected call of StockerIngrédient.
func (mr *MockStockMockRecorder) StockerIngrédient(ingrédient any) *MockStockStockerIngrédientCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StockerIngrédient", reflect.TypeOf((*MockStock)(nil).StockerIngrédient), ingrédient)
	return &MockStockStockerIngrédientCall{Call: call}
}

// MockStockStockerIngrédientCall wrap *gomock.Call
type MockStockStockerIngrédientCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStockStockerIngrédientCall) Return() *MockStockStockerIngrédientCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStockStockerIngrédientCall) Do(f func(recette.Ingrédient)) *MockStockStockerIngrédientCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStockStockerIngrédientCall) DoAndReturn(f func(recette.Ingrédient)) *MockStockStockerIngrédientCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VérifierDisponibilité mocks base method.
func (m *MockStock) VérifierDisponibilité(ingrédient recette.Ingrédient) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VérifierDisponibilité", ingrédient)
	ret0, _ := ret[0].(bool)
	return ret0
}

// VérifierDisponibilité indicates an expected call of VérifierDisponibilité.
func (mr *MockStockMockRecorder) VérifierDisponibilité(ingrédient any) *MockStockVérifierDisponibilitéCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VérifierDisponibilité", reflect.TypeOf((*MockStock)(nil).VérifierDisponibilité), ingrédient)
	return &MockStockVérifierDisponibilitéCall{Call: call}
}

// MockStockVérifierDisponibilitéCall wrap *gomock.Call
type MockStockVérifierDisponibilitéCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStockVérifierDisponibilitéCall) Return(arg0 bool) *MockStockVérifierDisponibilitéCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStockVérifierDisponibilitéCall) Do(f func(recette.Ingrédient) bool) *MockStockVérifierDisponibilitéCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStockVérifierDisponibilitéCall) DoAndReturn(f func(recette.Ingrédient) bool) *MockStockVérifierDisponibilitéCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
